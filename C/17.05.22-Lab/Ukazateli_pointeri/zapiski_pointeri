/*
Указателите - достъп до паметта, манипулират се адресите до данните.

пример:
Нека var e променлива
=> &var - нейният адрес в паметта.
& амперсант - референтен оператор.

Pointer* - сухранява само адреса дo променлива 

2.Деклариране:
деклариране на p kato променлива указател към тип int
int* p - тази звездичка не означава дереференция просто така се записва

3.Референция/ Дереференция:
--> Референция(&)
& - дава адреса
-->Дереференция(*)
* - стойността

Пример:
int var = 10;  
int *p;
p = &var; -> по този начин p складирa адреса на променливата var
P е поинтер, който съхранява адреса на променливата var
типовете им съвпадат, 
защото инт поинтер притежава адрес на инт променлива


4. Видове указатели:
а) Null pointer - стойността е Null, не сочи към нищо
#include<stdio.h>
int main()
{
    int *var = NULL;
    printf("var = %d", *var); // грешка
}

Б) void pointer - не е свързано с конкретен тип
#include<stdio.h>
int main()
{
   int a = 2;
   char c = 'a';

   void *ptr; // указател към неопределен тип

   ptr = &a; // adress
   int *temp = (int *)ptr; // указател темп ще сочи там където е ptr, но след като е кастнат 
   printf("After typecasting, a = %d\n", *temp); // After typecasting, a = 2
   printf("1.After typecasting, a = %d\n", *(int *)ptr); // After typecasting, a = 2

   ptr = &c;
   char *t = (char *)ptr;
   printf("After typecasting, a = %c\n", *t); // After typecasting, a = a
   printf("2.After typecasting, a = %c\n", *(char *)ptr); // After typecasting, a = a
   printf("3.Adress.After typecasting, a = %u\n", (char *)ptr); // a = 4064278787
   return 0;
}
// (int *) - превежда се указател към int  
// *(int *)ptr - кастнат указател, като му сложим *, става неговата стойност
// Ако не го кастнем - 


B) Wild pointer - декларира се, без да му се присвоява адрес.

Г) Висящ поинтер(dangling pointer) - Да предположим, че има указател p, сочещ променлива в адрес 
от паметта 1004.
Ако тази памет се освободи с помощта на функция free() , тогава това p се нарича висящ
указател.
#include<stdio.h>
#include<stdlib.h>
int main()
{
    int *ptr=(int *)malloc(sizeof(int));
    int a=5;
    ptr=&a;
    free(ptr); // освобождаваме, 

    //now this ptr is known as dangling pointer.
    printf("After deallocating its memory *ptr=%d", *ptr);
    return 0;
}

/*
Когато работим с указатели. Представете си че ние имме указател, който сочи към
една променлива, която заема памет 4б, ако е от тип int. 
И ние рещаваме да изтрием тази променлива, това става с free() - изтриваме стойността на
указателя, който сочи към нея. И се получава висащ указател. 
malloc() - отделя памет. Заделя толкова памет колкото е посочено в () 
*/


4. Приоритет
#include<stdio.h>
int main()
{
    int x =10
    int *p = &x; // в p e  записан адреса на x;

    y = *p + 1      --> y = x + 1;
    *p = *p + 10    --> x = x + 10;
    *p += 2         --> x+=2;
    ++*p            --> ++x;
    (*p)++          --> x ++ 

    //Последния ред за необходими скоби, защото унарните оператори се изчисляват от дясно на ляво
}


5. Двойни указатели:
int *p - в п е записан адреса на тази целочислена променлива
int **p - стойността на p е указател към int, но стойността на п сочи към друка клетка, но стойността на тази де клетка сочи към друга
ст-ст
*/